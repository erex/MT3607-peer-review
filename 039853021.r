#I confirm that the attached is my own work, except where clearly indicated in the text.	my.rnorm<-function(n,mean=0,sd=1) {#Purpose: converts numbers generated from the uniform distribution into normally-distributed deviates using the algorithm provided#Inputs (only accepts scalars): n – number of values to return (no default), mean – mean of values to return (default 0), sd – standard deviation of values to return (default 1)#Outputs: a vector of length n with pseudo-random values from a normal distributionif (length(n)>1) stop("invalid arguments\n")if (length(mean)>1) stop("invalid arguments\n")if (length(sd)>1) stop("invalid arguments\n")#These three lines of code stop the function if an input is entered that isn’t a scalar and returns the error message “invalid arguments”	vectorn<-numeric(n)	#Creates a vector called ‘vectorn’ of length n	for(i in 1:n) {	#Creates a for loop to generate n normally-distributed deviates using the algorithm provided and puts these deviates into the ith space in ‘vectorn’		Ui<-runif(16)		X<-((sum(Ui)-8)*sqrt(12/16))
		vectorn[i]<-(X*sd+mean)	}print(vectorn)#Prints vector length n of normally-distributed deviates}my.rchisq<-function(n,df=1) {#Purpose: converts numbers generated from the uniform distribution into chi-squared-distributed deviates#Inputs (only accepts scalars): n – number of values to return (no default), df – degrees of freedom of the distribution (default 1)#Outputs: a vector of length n with pseudo-random values from a chi-squared distribution with 1 degree of freedom (unless df specified otherwise)if (length(n)>1) stop("invalid arguments\n")if (length(df)>1) stop("invalid arguments\n")#These two lines of code stop the function if an input is entered that isn’t a scalar and returns the error message “invalid arguments”	nX2deviates<-numeric(n)	#Creates a vector called ‘nX2deviates’ of length n in which to later store the n chi-squared-distributed deviates generated with df degrees of freedom	for(j in 1:n) {	#Creates a for loop to generate n chi-squared-distributed deviates and store them in the jth space in ’nX2deviates’		vectordf<-numeric(df)		#Creates a vector called ‘vectordf’ of length df in which to later store the normal random deviates generated in the second for loop 		for(i in 1:df){		#Creates the second for loop which will generate df normally-distributed deviates using the algorithm provided, squaring each deviate and storing it into the ith space in ‘vectordf’			Ui<-runif(16)			X2<-(((sum(Ui)-8)*sqrt(12/16))^2)			vectordf[i]<-(X2)		}		X2deviate<-sum(vectordf)
		#Sums ‘vectordf’ and stores the result in ‘X2deviate’		nX2deviates[j]<-(X2deviate)	}print(nX2deviates)#Prints vector length n of chi-squared-distributed deviates}my.rf<-function(n,df1=1,df2=1) {#Purpose: converts numbers generated from the uniform distribution into F-distributed deviates#Inputs (only accepts scalars): n – number of values to return (no default), df1 – degrees of freedom of the numerator (default 1), df2 – degrees of freedom of the denominator (default 1)#Outputs: a vector of length n with pseudo-random values from an F-distribution with 1 degree of freedom for both the numerator and the denominator (unless df1 and/or df2 specified otherwise)if (length(n)>1) stop("invalid arguments\n")if (length(df1)>1) stop("invalid arguments\n")if (length(df2)>1) stop("invalid arguments\n")#These three lines of code stop the function if an input is entered that isn’t a scalar and returns the error message “invalid arguments”	nFdeviates<-numeric(n)	#Creates a vector called ‘nFdeviates’ of length n in which to later store the n F-distributed deviates generated with the numerator and denominator having df1 and df2 degrees of freedom respectively 	for(k in 1:n) {	#Creates a for loop to generate n F-distributed deviates and store them in the kth space in ’nFdeviates’		vectordf1<-numeric(df1)		#Creates a vector called ‘vectordf1’ of length df1 in which to later store the normal random deviates generated in the second for loop		for(i in 1:df1) {		#Creates a second for loop which will generate df1 normally-distributed deviates using the algorithm provided, squaring each deviate and storing it into the ith space in ‘vectordf1’			Ui<-runif(16)			X2<-(((sum(Ui)-8)*sqrt(12/16))^2)			vectordf1[i]<-(X2)		}		X2deviate<-sum(vectordf1)		#Sums ‘vectordf1’ and stores the result in ‘X2deviate’		vectordf2<-numeric(df2)		#Creates a vector called ‘vectordf2’ of length df2 in which to later store the normal random deviates generated in the third for loop		for(j in 1:df2) {		#Creates a third for loop which will generate df2 normally-distributed deviates using the algorithm provided, squaring each deviate and storing it into the jth space in ‘vectordf2’			Ui<-runif(16)			Y2<-(((sum(Ui)-8)*sqrt(12/16))^2)			vectordf2[j]<-(Y2)		}		Y2deviate<-sum(vectordf2)		#Sums ‘vectordf2’ and stores the result in ‘Y2deviate’		Fdeviate<-((X2deviate/df1)/(Y2deviate/df2))		#Calculates the value of the corresponding F deviate using the distribution theory theorem for F-distributed deviates		nFdeviates[k]<-(Fdeviate)	}print(nFdeviates)#Prints vector length n of F-distributed deviates}#This first test is to check the length of vectors in each of the three functions, first identifying if their length is correctly classified odd or even, and then ensuring that the vectors are in fact numeric and of the length specified in the function#x<-my.rnorm(100)#y<-my.rchisq(8)#z<-my.rf(5)#Assigns x to be a vector of 100 normally-distributed deviates, y to be a vector of 8 chi-squared-distributed deviates and z to be a vector of 5 F-distributed deviates using the functions I wrotelengthx<-length(x)#a<-lengthx %% 2 == 0
#print(a)#Will return “TRUE” if the length of the vector x is even (this should happen since x is a vector of length 100)#lengthy<-length(y)#b<-lengthy %% 2 == 0
#print(b)#Will return “TRUE” if the length of the vector x is even (this should happen since y is a vector of length 8)#lengthz<-length(z)#c<-lengthz %% 2 != 0
#print(c)#Will return “TRUE” if the length of the vector x is odd (this should happen since z is a vector of length 5)pass.test1<-(length(x)==100 & length(y)==8 & length(z)==5 & is.numeric(x) & is.numeric(y) & is.numeric(z))#pass.test takes on the value “TRUE” if and only if vectors x, y and z are numeric and of length 100, 8 and 5 respectively)#print(pass.test1)#This second test is to assess if the mean and standard deviation of the vector x I created using the my.rnorm code are 0 and 1 respectively as they should be set this way by default#roundmean<-round(mean(x))#roundsd<-round(sd(x))#pass.test2<-(roundmean==0 & roundsd==1)#pass.test takes on the value “TRUE” if and only if vectors the mean and standard deviation of vector x are 0 and 1 respectively)#print(pass.test2)

#This third test I wrote so I can also do a visual analysis of 2 graphs, the first being 100 random normal deviates I generated using the my.rnorm function I wrote, and the second being 100 random normal deviates generated using the random normal deviate generator in R.  Since n=100 in both cases, the graphs should look alike, with similar spread.
#par(mfrow=c(1,2))#plot(1:100,x)#plot(1:100,rnorm(100))