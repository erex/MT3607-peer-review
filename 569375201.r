#I confirm that the attached is my own work, except where clearly indicated in the text

my.rnorm<-
  function(n,m=0,d=1){
  # creates a function called my.rnorm, with m and d having default values  
    options(error=expression(NULL))
    if (n<1) stop("invalid arguments")
    # error trap
      z<-rep(0,n)
      # creates an empty vector(full of 0s) with n places, into which the results will be placed
      for(i in 1:n){
      # runs the loop for n iterations  
        u<-runif(16,0,1)
        # generates 16 random and uniformly distributed numbers between 0 and 1
        s<-sum(u)
        # sums these numbers
        z[i]<-m+((s-16/2)*sqrt(12/16))*d
        # tranforms the uniformly distibuted numbers to mimic normal distribution
        z<-c(z[1:n])
        # inputs these numbers into the results vector
      }
    return(z)
  }

# below is your test to see if the function generates the correct number of results
x<-my.rnorm(n=10)
pass.test<-(length(x)==10 & is.numeric(x))

qq.test<-
  function(n=10,m=10000){
  # creates a function based on the qq-plots of two different numbers of results
    par(mfrow=c(1,2))
    # specifies that the graphs will be shown horizontally next to each other
    x<-my.rnorm(n)
    # generates n normally distibuted numbers (default is 10)
    qqnorm(x, main=paste('QQ normal n=',n))
    # creates a graph from the above results
    qqline(x, col="red")
    # shows on the graph the diagonal line which the results should follow if they are normally distibuted
    x<-my.rnorm(m)
    # generates m normally distibuted numbers (default is 10000)
    qqnorm(x, main=paste('QQ normal n=',m))
    # creates a graph from the above results
    qqline(x, col="red")
    # shows on the graph the diagonal line which the results should follow if they are normally distibuted
    # this is a visual test - it works better with more results, 
    # hence at its default setting the second graph more obviously shows normal dist 
  }

norm.hist.test<-
  function(n,m=0,d=1){
  # creates a test based on the shape of a histogram 
  # i.e. if the function produces the bell curve that is expected from norm dist
    hist(my.rnorm(n,m,d),25, col="black")
    # plots a histogram of n numbers generated by my function
  }
  # this test works best with larger values of n (1000+)

norm.test<-
  function(n){
  # creates a function for testing if the numbers being generated are normally distibuted
    test<-(mean(my.rnorm(n)-rnorm(n))<0.05)
    # tests how similar my function is to the proper one in r 
    print(test)
    # shows if the test passes (returns TRUE) or fails
    # if n is small, a fail may result despite the two functions being similarly distributed
  }

my.rchisq<-
  function(n,df=1){
  # creates a function with a default value for the degree of freedom as 1
    options(error=expression(NULL))
    if (n<1) stop("invalid arguments")
    if (df<1) stop("invalid arguments")
    # error traps
      x<-rep(0,n)
      # creates an empty vector(full of 0s) with n places, into which the results will be placed
      x<-my.rnorm(n)^2
      # generates n normally distibuted number and squares them
      if (df>1){
      # if df is 1 then the result is acheived before this loop
        for (j in 1:(df-1)){
        # runs the loop until the required df is acheived
          y<-my.rnorm(n)^2
          # generates n normally distibuted number and squares them
          x<-x+y
          # adds these results to the respective results already in the results vector
        }
      }
    x
  }

# below is your test to see if the function generates the correct number of results
x<-my.rchisq(n=10)
pass.test<-(length(x)==10 & is.numeric(x))

chisq.test<-
  function(n,df=1){
    # creates a function for testing if the numbers being generated are of chi-squared distibution
    test<-(mean(my.rchisq(n,df)-rchisq(n,df))<0.05)
    # tests how similar my function is to the proper one in r
    print(test)
    # shows if the test passes (returns TRUE) or fails
    # if n is small, a fail may result despite the two functions being similarly distributed
  }

mean.test<-
  function(n,df=1){
    # creates a function for testing if the numbers being generated are of chi-squared distibution
    # based on the fact that under correct conditions the mean of a chi-squared dist is its degree of freedom
    test<-(abs(mean(my.rchisq(n,df))-df)<1)
    # runs the test
    print(test)
    # shows if the test passes (returns TRUE) or fails
    # the criteria of <1 is generous, 
    # but unless n is very large (10000+) the mean can randomly fluctuate too much to be more critical
  }

my.rf<-
  function(n,df1=1,df2=1){
  # creates a function with a default value for both the degrees of freedom as 1
    options(error=expression(NULL))
    if (n<1) stop("invalid arguments")
    if (df1<1) stop("invalid arguments")
    if (df2<1) stop("invalid arguments")
    # error traps
      u<-rep(0,n)
      # creates an empty vector(full of 0s) with n places, into which the results will be placed
      v<-rep(0,n)
      # creates an empty vector(full of 0s) with n places, into which the results will be placed
      u<-my.rchisq(n,df1)
      # generates n chi-squared distributed numbers
      v<-my.rchisq(n,df2)
      # generates n chi-squared distributed numbers
      f<-rep(0,n)
      # creates an empty vector(full of 0s) with n places, into which the results will be placed
      for (i in 1:n){
      # this loop will run n times  
        f[i]<-((u[i])/df1)/((v[i])/df2)
        # transforms the chi-squared distributed numbers into those from an f distribution
      }
    f
  }

# below is your test to see if the function generates the correct number of results
x<-my.rf(n=10)
pass.test<-(length(x)==10 & is.numeric(x))

f.test<-
  function(n,df1=1,df2=1){
    # creates a function for testing if the numbers being generated are of an f distibution
    test<-(mean(my.rf(n,df1,df2)-rf(n,df1,df2))<0.05)
    # tests how similar my function is to the proper one in r
    print(test)
    # shows if the test passes (returns TRUE) or fails
  }